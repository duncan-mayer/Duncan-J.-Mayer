<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Duncan J. Mayer">
<meta name="dcterms.date" content="2023-01-10">

<title>Duncan J. Mayer - On the Adjacency Matrix in ICAR and Convolution Prior Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Duncan J. Mayer</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/duncan-mayer"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/duncan-mayer"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">On the Adjacency Matrix in ICAR and Convolution Prior Models</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">spatial</div>
                <div class="quarto-category">simulation</div>
                <div class="quarto-category">r</div>
                <div class="quarto-category">base</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Duncan J. Mayer </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 10, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>This post explores the role of the adjacency matrix in determining spatial variation in the Intrinsic Conditional Auto-regressive (ICAR) and convolution prior models.</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Areal data, which consists of a finite set of bounded regions, in which measurements aggregated from each region’s population, are commonly encountered in many areas. For example, in US based research it is common to investigate occurrences of a phenomenon using administrative units such as counties, census tracts, or zip codes. When considering such spatial units, geographic scale becomes a key concern. Geographic scale consists of grain and extent, where grain refers to the resolution of sampling units,and extent refers to the total area under consideration (Simon, 1962). In many applications spatial heterogeneity is a looming threat and depends on scale, for example, working with large extent and coarse grain may mask spatial heterogeneity, only to see it emerge at finer grain, and patterns in ecological data can be confounded by trends at intermediate scales and noise at the smallest scales. Spatial methods provide a way of disentangling artifacts of geographic scale and patterns. The convolution prior (described below) is a widely used model that captures spatial and non-spatial heterogeneity, allowing a comparison of sources of variation, and more accurate estimation of focal effects.</p>
<p>This post first discusses the convolution prior, then using a series of simulations the post shows the ratio of spatial to non-spatial heterogeneity is primarily a function of the adjacency matrix, a feature that is not often discussed in applied work. Additionally, the simulations show standard approaches, such as model comparison, are not helpful in recovering the underlying neighborhood structure.</p>
</section>
<section id="the-icar-prior" class="level1">
<h1>The ICAR Prior</h1>
<p>The ICAR prior model was first introduced by Besag (1974) as a special case of the CAR prior, namely, when the model assumes complete spatial heterogeneity. Given a graph of neighbors which defines the pairs of regions which interact, the conditional distribution of the individual random variables defines a Gaussian Markov Random Field, while the joint distribution is multivariate normal with mean zero (Besag, 1974). The ICAR prior model can be written as</p>
<p><span class="math display">\[
\phi_i | \phi_{[i]} \sim N \left(\frac{\sum_{[i]} \phi_i }{d_i},
\frac{\sigma_\phi^2}{d_i} \right)
\]</span></p>
<p>where <span class="math inline">\(\phi_i\)</span> defines the spatial effect for neighborhood <span class="math inline">\(i\)</span>, and <span class="math inline">\([i]\)</span> indexes the neighbors of neighborhood <span class="math inline">\(i\)</span>, <span class="math inline">\(d_i\)</span> is the number of neighbors for neighborhood <span class="math inline">\(i\)</span>, and <span class="math inline">\(\sigma^2_\phi\)</span> is the common variance.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="the-adjacency-matrix" class="level2">
<h2 class="anchored" data-anchor-id="the-adjacency-matrix">The Adjacency Matrix</h2>
<p>The precision matrix for the multivariate normal that defines the joint distribution of the spatial effects is derived from a diagonal matrix and an adjacency matrix, both are <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> matrices, where the diagonal matrix contains the number of neighbors corresponding to neighborhood <span class="math inline">\(i\)</span> in entry <span class="math inline">\(n_{ii}\)</span> while the adjacency matrix is often binary, containing a “1” in entry <span class="math inline">\(n_{ij}\)</span> if neighborhoods <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are neighbors, and “0” otherwise<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Clearly, the specification of the adjacency matrix has implications for the estimates of <span class="math inline">\(\phi_i\)</span>. In the equation for the ICAR shown above, it is clear that the total number of neighbors can change the estimates: the specification of neighbors in the sum change the estimates for the mean, as it is calculated conditional on the neighbors. It is likely that a high number of neighbors increases the spatial effects to the extent that they outpace the increase in the denominator. Further, the variance decreases as a function of the number of neighbors defined in the adjacency matrix.</p>
</section>
<section id="the-convolution-prior-model" class="level2">
<h2 class="anchored" data-anchor-id="the-convolution-prior-model">The Convolution Prior Model</h2>
<p>The ICAR prior assumes complete spatial autocorrelation, which can be viewed as a is a strong prior on the source of variation when included in isolation: fixing non-spatial variation at zero. The convolution prior (Besag, York, and Mollié, 1991) relaxes this assumption by including a spatially structured effect (ICAR) and an unstructured random effect that varies over the spatial units. Commonly, this comes in the form of the Besag-York-Mollié (BYM) model, which places the two random effects in the context of a log-Poisson model, often with an exposure term. With covariates outcome <span class="math inline">\(Y_i\)</span> for spatial units <span class="math inline">\(i\)</span>, covariates <span class="math inline">\(X\)</span> and offset <span class="math inline">\(p_i\)</span>, the BYM can be written as</p>
<p><span class="math display">\[
Y_i \sim Poisson(\lambda_i)
\]</span></p>
<p><span class="math display">\[
ln(\lambda_i) \equiv ln(p_i) + X\beta + \phi_i + \delta_i
\]</span></p>
<p><span class="math display">\[
\phi_i | \phi_{[i]} \sim N \left(\frac{\sum_{[i]} \phi_i }{d_i},
\frac{\sigma_\phi^2}{d_i} \right) \; \textrm{and} \;
\delta_i \sim N(0, \sigma^2_{\delta})
\]</span></p>
<p>The convolution prior model often requires sensible priors, estimating two random effects when one measurement is taken from each spatial unit the posteriors may be sensitive to the selection of priors in the full Bayesian context. Additionally, sensible priors (or “fair”, in the sense that they equally weight spatial and non-spatial variation) are difficult to generate as the ICAR is specified conditionally while the unstructured effect is specified marginally<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. However, it is often tempting to compare the sources of variation, declaring a percent of the variation in the outcome due to spatially structured variation, or non-spatially structured variation. For example, one may compute <span class="math inline">\(\sigma^2_\phi / (\sigma^2_\phi + \sigma^2_\delta)\)</span>. Yet, as described above, the posterior of the variance may depend heavily on the specification of the adjacency matrix, an issue under-researched in the literature. Accordingly, this post explores the sensitivity of the posterior estimates to the specification of the adjacency matrix, as well as the ability of the model to recover the correct neighborhood structure.</p>
</section>
</section>
<section id="simulation-study" class="level1">
<h1>Simulation Study</h1>
<section id="defining-adjacency-matrices" class="level2">
<h2 class="anchored" data-anchor-id="defining-adjacency-matrices">Defining Adjacency Matrices</h2>
<p>To simulate the convolution prior, I first must specify a neighborhood graph. For the purpose of this post, I’m going to use Cuyahoga County Ohio’s Census Tracts, with 2010 geographic boundaries. I will generate a total of 6 adjacency matrices to show how rapidly the number of neighbors increase, although in the eventual in the simulation study, I will focus on “queen” contiguity as it is the most commonly used, and entertaining all patterns would be much too long for a post, although the idea holds for other patterns.</p>
<p>I define all adjacency matrices to be binary, varying the order of neighbors from 1-3. Below, I’ve written a function to help create the various adjacency matrices that will be used in this study.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'ggplot2'</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'INLA'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">101</span>) <span class="co"># reproducibility</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ca <span class="ot">&lt;-</span> tigris<span class="sc">::</span><span class="fu">tracts</span>(<span class="at">state =</span> <span class="st">"OH"</span>, <span class="at">county =</span> <span class="st">"Cuyahoga"</span>, <span class="at">year =</span> <span class="dv">2010</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># remove water </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ca <span class="ot">&lt;-</span> ca[ca<span class="sc">$</span>TRACTCE10 <span class="sc">!=</span>  <span class="dv">990000</span>,]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>ca<span class="sc">$</span>areaid <span class="ot">&lt;-</span> ca<span class="sc">$</span>TRACTCE10</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># helper function for weight matrix </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>create_neighborhood_matrix <span class="ot">&lt;-</span> <span class="cf">function</span>(geo, geo_names, <span class="at">queen =</span> <span class="cn">TRUE</span>, <span class="at">style =</span> <span class="st">"B"</span>, <span class="at">order =</span> <span class="dv">1</span>) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">class</span>(geo)[<span class="dv">1</span>] <span class="sc">!=</span> <span class="st">"sfc_MULTIPOLYGON"</span>) {<span class="fu">stop</span>(<span class="st">"geo must be of class sfc_MULTIPOLYGON"</span>)} </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  w <span class="ot">&lt;-</span> spdep<span class="sc">::</span><span class="fu">poly2nb</span>(geo, <span class="at">row.names =</span> geo_names, <span class="at">queen =</span> queen)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">class</span>(w) <span class="sc">!=</span> <span class="st">"nb"</span>) {<span class="fu">stop</span>(<span class="st">"w must be of class nb"</span>)}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (order <span class="sc">&lt;</span> <span class="dv">1</span> <span class="sc">|</span> order <span class="sc">&gt;</span> <span class="dv">3</span>) {<span class="fu">stop</span>(<span class="st">"order of neighbors must be 1, 2, or 3"</span>)}</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (order <span class="sc">==</span> <span class="dv">1</span>) {mat <span class="ot">&lt;-</span> spdep<span class="sc">::</span><span class="fu">nb2mat</span>(w, <span class="at">style =</span> style)}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (order <span class="sc">%in%</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">3</span>)) {</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      wl <span class="ot">&lt;-</span> spdep<span class="sc">::</span><span class="fu">nblag</span>(w, <span class="at">maxlag =</span> order)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      wl <span class="ot">&lt;-</span> spdep<span class="sc">::</span><span class="fu">nblag_cumul</span>(wl)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      mat <span class="ot">&lt;-</span> spdep<span class="sc">::</span><span class="fu">nb2mat</span>(wl, <span class="at">style =</span> style)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(mat)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As I define the neighbors to be of higher order, the average number of neighbors increases dramatically, for example, the average number of neighbors for each unit increases from 6 to 41 using queen contiguity, and from 5 to 36 for rook contiguity, as we vary the order of neighbors from 1 to 3.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>outq <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>outr <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ( i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>outq[[i]] <span class="ot">&lt;-</span> <span class="fu">create_neighborhood_matrix</span>(<span class="at">geo =</span> ca<span class="sc">$</span>geometry, <span class="at">geo_names =</span> ca<span class="sc">$</span>TRACTCE10, <span class="at">order =</span> i)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>outr[[i]] <span class="ot">&lt;-</span> <span class="fu">create_neighborhood_matrix</span>(<span class="at">geo =</span> ca<span class="sc">$</span>geometry,<span class="at">queen =</span> <span class="cn">FALSE</span>, <span class="at">geo_names =</span> ca<span class="sc">$</span>TRACTCE10, <span class="at">order =</span> i)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>nlist <span class="ot">&lt;-</span> <span class="fu">c</span>(outq, outr)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>dfoutq <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind.data.frame, <span class="fu">lapply</span>(outq, \(x) <span class="fu">sum</span>(x) <span class="sc">/</span> <span class="fu">dim</span>(x)[<span class="dv">1</span>]))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>dfoutr <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind.data.frame, <span class="fu">lapply</span>(outr, \(x) <span class="fu">sum</span>(x) <span class="sc">/</span> <span class="fu">dim</span>(x)[<span class="dv">1</span>]))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>outn <span class="ot">&lt;-</span> <span class="fu">cbind</span>(dfoutq, dfoutr)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(outn) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Queen"</span>, <span class="st">"Rook"</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>outn<span class="sc">$</span>Order <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>gt<span class="sc">::</span><span class="fu">gt</span>(<span class="fu">round</span>(outn, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">

<div id="iynwqzvcci" style="overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>html {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;
}

:where(#iynwqzvcci) .gt_table {
  display: table;
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

:where(#iynwqzvcci) .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 0;
  padding-bottom: 6px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

:where(#iynwqzvcci) .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

:where(#iynwqzvcci) .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

:where(#iynwqzvcci) .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

:where(#iynwqzvcci) .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

:where(#iynwqzvcci) .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

:where(#iynwqzvcci) .gt_group_heading {
  padding: 8px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
}

:where(#iynwqzvcci) .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

:where(#iynwqzvcci) .gt_from_md > :first-child {
  margin-top: 0;
}

:where(#iynwqzvcci) .gt_from_md > :last-child {
  margin-bottom: 0;
}

:where(#iynwqzvcci) .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

:where(#iynwqzvcci) .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 12px;
}

:where(#iynwqzvcci) .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

:where(#iynwqzvcci) .gt_first_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

:where(#iynwqzvcci) .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

:where(#iynwqzvcci) .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding: 4px;
}

:where(#iynwqzvcci) .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

:where(#iynwqzvcci) .gt_sourcenote {
  font-size: 90%;
  padding: 4px;
}

:where(#iynwqzvcci) .gt_left {
  text-align: left;
}

:where(#iynwqzvcci) .gt_center {
  text-align: center;
}

:where(#iynwqzvcci) .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

:where(#iynwqzvcci) .gt_font_normal {
  font-weight: normal;
}

:where(#iynwqzvcci) .gt_font_bold {
  font-weight: bold;
}

:where(#iynwqzvcci) .gt_font_italic {
  font-style: italic;
}

:where(#iynwqzvcci) .gt_super {
  font-size: 65%;
}

:where(#iynwqzvcci) .gt_footnote_marks {
  font-style: italic;
  font-weight: normal;
  font-size: 65%;
}
</style>
<table class="gt_table">
  
  <thead class="gt_col_headings">
    <tr>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">Queen</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">Rook</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">Order</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td class="gt_row gt_right">6.10</td>
<td class="gt_row gt_right">5.34</td>
<td class="gt_row gt_right">1</td></tr>
    <tr><td class="gt_row gt_right">19.63</td>
<td class="gt_row gt_right">17.17</td>
<td class="gt_row gt_right">2</td></tr>
    <tr><td class="gt_row gt_right">41.58</td>
<td class="gt_row gt_right">36.34</td>
<td class="gt_row gt_right">3</td></tr>
  </tbody>
  
  
</table>
</div>
</div>
</div>
</section>
<section id="simulating-the-convolution-prior" class="level2">
<h2 class="anchored" data-anchor-id="simulating-the-convolution-prior">Simulating the Convolution Prior</h2>
<p>In the code below, for a given adjacency matrix, I create a function with simulates data consistent with the neighbor graph following the process of a convolution prior on the log scale, with 3 covariates sampled from a multivariate normal and an offset sampled from a uniform distribution. In the code below, the spatial effect is generated using <code>SUMMER</code> and labeled <code>sp</code> while the unstructured variation is <code>unstruc</code>. There are two features worth noting here. First, the random effects are uncorrelated with the covariates, a simplifying assumption of the BYM model. Second, the unstructured variation is sampling from a normal distribution with standard deviation defined as equal to the standard deviation of the spatially structured variation. This ensures they are equal, on average, when the data are simulated.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>simulate_bym_df <span class="ot">&lt;-</span>  <span class="cf">function</span>(neighborhoodmat, <span class="at">n =</span> <span class="fu">dim</span>(neighborhoodmat)[<span class="dv">1</span>], <span class="at">bx =</span> <span class="fu">c</span>(.<span class="dv">08</span>,<span class="sc">-</span>.<span class="dv">03</span>,<span class="sc">-</span>.<span class="dv">04</span>),</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>), </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">sigma =</span> <span class="fu">matrix</span>(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">data =</span> <span class="fu">c</span>(<span class="fl">1.11</span>, <span class="fl">0.30</span>, <span class="sc">-</span><span class="fl">0.15</span>,  </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                                              <span class="fl">0.30</span>,  <span class="fl">0.84</span>,  <span class="fl">0.25</span>, </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                                              <span class="sc">-</span><span class="fl">0.15</span>,  <span class="fl">0.25</span>,  <span class="fl">2.00</span>), <span class="at">nrow =</span> <span class="dv">3</span>)) {</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># create data</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  dft <span class="ot">&lt;-</span> MASS<span class="sc">::</span><span class="fu">mvrnorm</span>(n, <span class="at">mu =</span> mu, <span class="at">Sigma =</span> sigma)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  sp <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(SUMMER<span class="sc">::</span><span class="fu">rst</span>(<span class="at">n=</span> <span class="dv">1</span>, <span class="at">n.t =</span> <span class="dv">1</span>, <span class="at">type =</span> <span class="st">"s"</span>, </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                              <span class="at">Amat =</span> neighborhoodmat, <span class="at">scale.model =</span> <span class="cn">TRUE</span>)) <span class="co"># spatial random effect, ICAR</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  offset_pop <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">runif</span>(n, <span class="at">min =</span> <span class="dv">100</span>, <span class="at">max =</span> <span class="dv">1000</span>), <span class="dv">0</span>) <span class="co"># population size</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  unstruc <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, <span class="fu">sd</span>(sp)) <span class="co"># simulate normal, unstructured random effect with standard deviation equal to spatial variation</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  mu_p <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="dv">0</span> <span class="sc">+</span> <span class="dv">1</span><span class="sc">*</span><span class="fu">log</span>(offset_pop) <span class="sc">+</span> dft <span class="sc">%*%</span> bx <span class="sc">+</span> sp <span class="sc">+</span> unstruc) <span class="co"># generate mean function </span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  yy <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(<span class="fu">rpois</span>(n, <span class="at">lambda =</span> mu_p)) <span class="co"># poisson </span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  dft <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">cbind</span>(dft, yy, sp, unstruc, offset_pop, mu_p)) <span class="co"># package data</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  dft<span class="sc">$</span>areaid <span class="ot">&lt;-</span> <span class="fu">row.names</span>(neighborhoodmat) <span class="co"># create ids</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(dft)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With functions to create a neighborhood structure of our choice and generate data following the convolution prior with ecological covariates, all that’s left to do before fitting the models is create the data.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create data </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>dfqlist <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sdq <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ( i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># underlying structure of spatial correlation is queen with order 1-3</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>dfqlist[[i]] <span class="ot">&lt;-</span>  <span class="fu">simulate_bym_df</span>(<span class="at">neighborhoodmat =</span>  </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                                <span class="fu">create_neighborhood_matrix</span>(<span class="at">geo =</span> ca<span class="sc">$</span>geometry, <span class="at">geo_names =</span> ca<span class="sc">$</span>TRACTCE10, <span class="at">order =</span> i))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>dflist <span class="ot">&lt;-</span> dfqlist</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>In the code below I fit models model with the convolution prior using 3 data sets, each 3 times, varying only the specification of the adjacency matrix<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. I use Integrated Nested Laplace Approximation (INLA) with the vague priors that <code>inla</code> has as default (diffuse log-gamma for spatial and non-spatial variance). INLA uses optimization rather than sampling, and while I typically prefer the full Bayesian methodology, INLA is often very efficient for latent Gaussian models and I’m fitting several of them here.</p>
<p>Having fit the 9 models, I then extract the hyper-parameters transformed (which are transformed into standard deviation) and show the results in the figure below. The top row of the figure shows a summary of the posterior for the standard deviation for the standard deviation of the non-spatial effect, while the second row shows the standard deviation of the spatial variation. The number underneath the label for the source of variation indicates the order of neighbors used to simulate the ICAR.</p>
<p>There are several notable features of the posterior summaries. As I suggested when inspecting the model in the first section, in all cases the posterior interval of the spatial variation decreases as the order of neighbors, and the average number of neighbors, increases. Additionally, at least when the true order of neighbors is above 1, the standard deviation of the spatial effect increases linearly with the order of neighbors assumed in the construction of the adjacency matrix. When the true order is 1, however, the standard deviation increases when the order jumps for 1 to 2, but not from 2 to 3. As the two random effects in the BYM model compete for variation, the non-spatial standard deviation decreases as a function of the number of neighbors. In this sense, the simulation shows that <em>the percent of variance that is spatially structured is largely an artifact of the adjacency matrix</em>.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fitf <span class="ot">&lt;-</span> <span class="cf">function</span>(neigh, df) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  INLA FORMULA</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>form <span class="ot">&lt;-</span> yy <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> V1 <span class="sc">+</span> V2 <span class="sc">+</span> V3 <span class="sc">+</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">f</span>(areaid, <span class="at">model =</span> <span class="st">"bym"</span>, </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">graph =</span> neigh, <span class="at">values =</span> <span class="fu">row.names</span>(neigh), <span class="at">scale.model =</span> <span class="cn">TRUE</span>) </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">inla</span>(<span class="at">formula =</span> form,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">family=</span> <span class="st">"poisson"</span>, <span class="at">offset =</span> <span class="fu">log</span>(offset_pop),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">data=</span>df,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">control.family=</span><span class="fu">list</span>(<span class="at">link=</span><span class="st">'log'</span>),</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">control.predictor=</span><span class="fu">list</span>(<span class="at">link=</span><span class="dv">1</span>, <span class="at">compute=</span><span class="cn">TRUE</span>),</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>     <span class="at">control.compute=</span><span class="fu">list</span>(<span class="at">dic=</span><span class="cn">TRUE</span>, <span class="at">cpo=</span><span class="cn">TRUE</span>, <span class="at">waic=</span><span class="cn">TRUE</span>))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>mout <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(brinla<span class="sc">::</span><span class="fu">bri.hyperpar.summary</span>(m))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>mout<span class="sc">$</span>empircal_sdsp <span class="ot">&lt;-</span> <span class="fu">sd</span>(df<span class="sc">$</span>sp)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>mout<span class="sc">$</span>empircal_sdun <span class="ot">&lt;-</span> <span class="fu">sd</span>(df<span class="sc">$</span>unstruc)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>mout<span class="sc">$</span>waic <span class="ot">&lt;-</span> m<span class="sc">$</span>waic<span class="sc">$</span>waic</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span>(mout)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co"># index book keeping to avoid nested loop</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>modlist <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(tr<span class="sc">$</span>Var1) ) {</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>modlist[[i]] <span class="ot">&lt;-</span> <span class="fu">fitf</span>(nlist[[tr<span class="sc">$</span>Var1[[i]]]], dflist[[tr<span class="sc">$</span>Var2[[i]]]])</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(tr) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"neigh"</span>, <span class="st">"df"</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>hyper_results <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind.data.frame, modlist)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># label componenets</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>hyper_results<span class="sc">$</span>com <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"iid Variation"</span>,<span class="st">"Spatial Variation"</span>))</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co"># combine results </span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>hyper_results <span class="ot">&lt;-</span> <span class="fu">rbind</span>(<span class="fu">cbind</span>(hyper_results[hyper_results<span class="sc">$</span>com <span class="sc">==</span> <span class="st">"iid Variation"</span>,], tr), <span class="fu">cbind</span>(hyper_results[hyper_results<span class="sc">$</span>com <span class="sc">==</span> <span class="st">"Spatial Variation"</span>,], tr))</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>hyper_results<span class="sc">$</span>neigh <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(hyper_results<span class="sc">$</span>neigh )</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="co"># plot hyper-parameters over adjacnecy specifications</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(hyper_results, <span class="fu">aes</span>(<span class="at">y =</span> mean, <span class="at">x =</span> neigh, </span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>                          <span class="at">ymin =</span> q0<span class="fl">.025</span>, <span class="at">ymax =</span> q0<span class="fl">.975</span>)) <span class="sc">+</span> <span class="fu">geom_pointrange</span>() <span class="sc">+</span> </span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">y =</span> <span class="st">"Mean and Posterior Interval"</span>, <span class="at">x =</span> <span class="st">"Order of Neighors (assumed)"</span>) <span class="sc">+</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(. <span class="sc">~</span> com <span class="sc">+</span> df, <span class="at">scales =</span> <span class="st">"fixed"</span>) <span class="sc">+</span> <span class="fu">theme_classic</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="icar_note_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="does-model-comparison-help" class="level1">
<h1>Does Model Comparison Help?</h1>
<p>The discussion and simulation shown above suggests the results depend heavily on the choice of neighbor order when creating an adjacency matrix. So, now I consider if the adjacency matrix can be recovered through model comparison. Here, I use the Watanabe–Akaike information criterion (WAIC), which is a measure of prediction error that does not require the true distribution, and is often preferred in the Bayesian setting as it integrates over the full posterior in contrast to, for example, DIC, which relies on the posterior mean (Gelman et al., 2014). If one is further willing to assume that the true model is among the candidates considers (i.e.&nbsp;M-closed), which is verifiable the data are simulated, relative WAIC can be used create weights that sum to 1 and yield the probability that the model is correct (Wagenmakers &amp; Farrell, 2004).</p>
<p>In the code below I generate weights for the 3 models considered under each data set. The table shows the order of neighbors assumed in the adjacency matrix used in the model, the order of neighbors used when simulating the data (“true”), the WAIC, and the weight. A correct model is one where the orders agree.</p>
<p>Clearly, model comparison is not helpful in this situation. The weights are comparable across models, as predictive performance is largely unable to discern between adjacency matrices. However, assuming third order neighbors achieves the “best” predictive performance in all situations, despite being incorrect in two occasions. These results suggest the true order of neighbors can not be recovered by conventional model comparison.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>waictab <span class="ot">&lt;-</span> hyper_results[<span class="sc">!</span><span class="fu">duplicated</span>(hyper_results<span class="sc">$</span>waic), <span class="fu">c</span>(<span class="st">"neigh"</span>, <span class="st">"df"</span>, <span class="st">"waic"</span>)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>create_weights <span class="ot">&lt;-</span> <span class="cf">function</span>(ic) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  delta <span class="ot">&lt;-</span> ic <span class="sc">-</span> <span class="fu">min</span>(ic)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  exp_delta <span class="ot">&lt;-</span> <span class="fu">exp</span>((<span class="sc">-</span>.<span class="dv">5</span>)<span class="sc">*</span>delta)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  denom <span class="ot">&lt;-</span> <span class="fu">sum</span>(exp_delta)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  prob_m <span class="ot">&lt;-</span> exp_delta <span class="sc">/</span> denom</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  icweights <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(delta, exp_delta, denom, prob_m)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span>(icweights)  </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>outt <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">table</span>(waictab<span class="sc">$</span>df))) {</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> waictab[waictab<span class="sc">$</span>df <span class="sc">==</span> i, ]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  temp<span class="sc">$</span>weight <span class="ot">&lt;-</span> <span class="fu">create_weights</span>(temp<span class="sc">$</span>waic)<span class="sc">$</span>prob_m</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  outt[[i]] <span class="ot">&lt;-</span> temp</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>waictab<span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind.data.frame, outt)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>waictab[,<span class="dv">3</span><span class="sc">:</span><span class="dv">4</span>] <span class="ot">&lt;-</span> <span class="fu">round</span>(waictab[,<span class="dv">3</span><span class="sc">:</span><span class="dv">4</span>],<span class="dv">2</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>gt<span class="sc">::</span><span class="fu">cols_label</span>(gt<span class="sc">::</span><span class="fu">gt</span>(waictab[<span class="fu">order</span>(<span class="sc">-</span>waictab<span class="sc">$</span>weight),]), </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">neigh =</span> <span class="st">"Order (model)"</span>, <span class="at">df =</span> <span class="st">"Order (true)"</span>, <span class="at">waic =</span> <span class="st">"WAIC"</span>, <span class="at">weight =</span> <span class="st">"Weight"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">

<div id="bkaaxzdoxf" style="overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>html {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;
}

:where(#bkaaxzdoxf) .gt_table {
  display: table;
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

:where(#bkaaxzdoxf) .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 0;
  padding-bottom: 6px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

:where(#bkaaxzdoxf) .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

:where(#bkaaxzdoxf) .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

:where(#bkaaxzdoxf) .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

:where(#bkaaxzdoxf) .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

:where(#bkaaxzdoxf) .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

:where(#bkaaxzdoxf) .gt_group_heading {
  padding: 8px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
}

:where(#bkaaxzdoxf) .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

:where(#bkaaxzdoxf) .gt_from_md > :first-child {
  margin-top: 0;
}

:where(#bkaaxzdoxf) .gt_from_md > :last-child {
  margin-bottom: 0;
}

:where(#bkaaxzdoxf) .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

:where(#bkaaxzdoxf) .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 12px;
}

:where(#bkaaxzdoxf) .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

:where(#bkaaxzdoxf) .gt_first_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

:where(#bkaaxzdoxf) .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

:where(#bkaaxzdoxf) .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding: 4px;
}

:where(#bkaaxzdoxf) .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

:where(#bkaaxzdoxf) .gt_sourcenote {
  font-size: 90%;
  padding: 4px;
}

:where(#bkaaxzdoxf) .gt_left {
  text-align: left;
}

:where(#bkaaxzdoxf) .gt_center {
  text-align: center;
}

:where(#bkaaxzdoxf) .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

:where(#bkaaxzdoxf) .gt_font_normal {
  font-weight: normal;
}

:where(#bkaaxzdoxf) .gt_font_bold {
  font-weight: bold;
}

:where(#bkaaxzdoxf) .gt_font_italic {
  font-style: italic;
}

:where(#bkaaxzdoxf) .gt_super {
  font-size: 65%;
}

:where(#bkaaxzdoxf) .gt_footnote_marks {
  font-style: italic;
  font-weight: normal;
  font-size: 65%;
}
</style>
<table class="gt_table">
  
  <thead class="gt_col_headings">
    <tr>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1">Order (model)</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">Order (true)</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">WAIC</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1">Weight</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td class="gt_row gt_center">3</td>
<td class="gt_row gt_right">2</td>
<td class="gt_row gt_right">4313.40</td>
<td class="gt_row gt_right">0.39</td></tr>
    <tr><td class="gt_row gt_center">3</td>
<td class="gt_row gt_right">1</td>
<td class="gt_row gt_right">4297.99</td>
<td class="gt_row gt_right">0.36</td></tr>
    <tr><td class="gt_row gt_center">3</td>
<td class="gt_row gt_right">3</td>
<td class="gt_row gt_right">4290.54</td>
<td class="gt_row gt_right">0.36</td></tr>
    <tr><td class="gt_row gt_center">2</td>
<td class="gt_row gt_right">2</td>
<td class="gt_row gt_right">4313.68</td>
<td class="gt_row gt_right">0.34</td></tr>
    <tr><td class="gt_row gt_center">1</td>
<td class="gt_row gt_right">1</td>
<td class="gt_row gt_right">4298.15</td>
<td class="gt_row gt_right">0.33</td></tr>
    <tr><td class="gt_row gt_center">2</td>
<td class="gt_row gt_right">3</td>
<td class="gt_row gt_right">4290.75</td>
<td class="gt_row gt_right">0.33</td></tr>
    <tr><td class="gt_row gt_center">2</td>
<td class="gt_row gt_right">1</td>
<td class="gt_row gt_right">4298.24</td>
<td class="gt_row gt_right">0.31</td></tr>
    <tr><td class="gt_row gt_center">1</td>
<td class="gt_row gt_right">3</td>
<td class="gt_row gt_right">4290.84</td>
<td class="gt_row gt_right">0.31</td></tr>
    <tr><td class="gt_row gt_center">1</td>
<td class="gt_row gt_right">2</td>
<td class="gt_row gt_right">4314.08</td>
<td class="gt_row gt_right">0.28</td></tr>
  </tbody>
  
  
</table>
</div>
</div>
</div>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In this post I have described the ICAR and convolution prior models, as well as the BYM model which places them in the setting of a log-poisson. I’ve focused on the role of the adjacency matrix in the ICAR component and suggested it is important in determining the posterior of the ICAR’s variance. Using simulation, I showed that varying only the order of neighbors in the adjacency matrix changes the estimates of the posterior, as well as the corresponding unstructured effect. Finally, I showed that model comparison is not helpful in recovering the true order of neighbors.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>Banerjee, S., Carlin, B. P., &amp; Gelfand, A. E. (2003). <em>Hierarchical Modeling and Analysis for Spatial Data</em> (1st edition). Chapman and Hall/CRC.</p>
<p>Besag, J. 1974. “Spatial Interaction and the Statistical Analysis of Lat-<br>
tice Systems.” Journal of the Royal Statistical Society. Series B (Methodological).<br>
JSTOR, 192–236.</p>
<p>Besag, J, J York, and A Mollié. 1991. “Bayesian Image Restoration with<br>
Two Applications in Spatial Statistics.” Ann Inst Stat Math 43: 1–59. (https:<br>
//doi.org/10.1007).</p>
<p>Earnest, A., Morgan, G., Mengersen, K., Ryan, L., Summerhayes, R., &amp; Beard, J. (2007). Evaluating the effect of neighbourhood weight matrices on smoothing properties of Conditional Autoregressive (CAR) models. <em>International Journal of Health Geographics</em>, <em>6</em>(1), 54. https://doi.org/10.1186/1476-072X-6-54</p>
<p>Gelman, A., Hwang, J., &amp; Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. <em>Statistics and Computing</em>, <em>24</em>(6), 997–1016. https://doi.org/10.1007/s11222-013-9416-2</p>
<p>Riebler, A., Sørbye, S. H., Simpson, D., &amp; Rue, H. (2016). An intuitive Bayesian spatial model for disease mapping that accounts for scaling. <em>Statistical Methods in Medical Research</em>, <em>25</em>(4), 1145–1165. https://doi.org/10.1177/0962280216660421</p>
<p>Simon, H., A. 1962. The architecture of complexity. <em>Proceedings of the American Philosophical Society</em> <strong>106</strong>:467-482</p>
<p>Wagenmakers, E.-J., &amp; Farrell, S. (2004). AIC model selection using Akaike weights. <em>Psychonomic Bulletin &amp; Review</em>, <em>11</em>(1), 192–196. https://doi.org/10.3758/BF03206482</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Following recent convention, this post defines things in terms of standard deviation and variance, rather than precision as is found in many of the older references (e.g., Besag, 1974).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Given the diagonal matrix <span class="math inline">\(D\)</span> and the adjacency matrix <span class="math inline">\(A\)</span>, the precision matrix <span class="math inline">\(Q\)</span> is found by <span class="math inline">\(Q = D(I - \alpha A)\)</span>, where <span class="math inline">\(\alpha\)</span> is set to 1 in the ICAR. This post entertains binary adjacency matrices, although the broader literature often includes other forms, such as row or global standardization, or measures of similarity (see, for example, Earnest et al., 2007). These are simple to implement, however, the applied literature often focuses on the binary specification.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Taking this issues seriously is challenging (see Banerjee et al., 2003). Recent advances in the Complexity Penalizing framework have resulting in clever reparameterizations, see (Riebler et al., 2016).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>I know nested loops have fallen out of favor, and this isn’t the most elegant solution to getting around them, but as J.D. Long says, “I’d have written a shorter solution but I didn’t have the time”<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>